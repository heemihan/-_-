<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>수박 게임 - 통합 수정본</title>
    <style>
        body {
            margin: 0; padding: 0;
            display: flex; justify-content: center; align-items: center;
            height: 100vh; background-color: #1a1a1a;
            overflow: hidden; font-family: 'Pretendard', sans-serif;
        }

        /* 캔버스가 늘어나지 않도록 크기를 고정합니다 */
        #game-container {
            position: relative;
            width: 400px;
            height: 600px;
            background-color: #ffeeb0;
            border: 4px solid #333;
            border-radius: 12px;
            overflow: hidden; /* 캔버스가 튀어나가지 않게 설정 */
        }

        /* 버튼들을 담는 레이어 */
        .top-controls {
            position: absolute; top: 15px; right: 15px;
            display: flex; gap: 10px;
            z-index: 101; /* 캔버스보다 위에 위치 */
        }

        .control-btn {
            width: 40px; height: 40px;
            cursor: pointer;
            pointer-events: auto;
        }

        .score-board {
            position: absolute; top: 20px; left: 20px;
            color: #333; font-size: 24px; font-weight: 800;
            z-index: 101;
            pointer-events: none;
        }

        /* Matter.js가 생성하는 캔버스 스타일 강제 고정 */
        canvas {
            display: block;
            max-width: 100%;
            max-height: 100%;
        }
    </style>
</head>
<body>

    <div id="game-container">
        <div class="score-board">SCORE: <span id="score">0</span></div>
        
        <div class="top-controls">
            <img src="asset/imgchange.png" class="control-btn" onclick="toggleSkin()" alt="Skin">
            <img src="asset/resetGame.png" class="control-btn" onclick="resetGame()" alt="Reset">
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <script>
        const { Engine, Render, Runner, Bodies, Composite, Events, Body } = Matter;

        const engine = Engine.create();
        const world = engine.world;
        const container = document.getElementById('game-container');

        // 상태 변수
        let currentSkinType = 'A'; 
        const mergeQueue = []; 
        let score = 0;
        let isGameOver = false;
        let currentFruit = null;
        let canDrop = true;

        const FRUITS = [
            { radius: 17.5, score: 2 }, { radius: 27.5, score: 4 }, { radius: 42.5, score: 8 },
            { radius: 52.5, score: 16 }, { radius: 67.5, score: 32 }, { radius: 82.5, score: 64 },
            { radius: 97.5, score: 128 }, { radius: 117.5, score: 256 }, { radius: 137.5, score: 512 },
            { radius: 157.5, score: 1024 }, { radius: 187.5, score: 2048 }
        ];

        // 1. 렌더러 설정 (container 내부에 캔버스 생성)
        const render = Render.create({
            element: container,
            engine: engine,
            options: {
                width: 400,
                height: 600,
                wireframes: false,
                background: 'transparent'
            }
        });

        // 2. 벽 생성
        const wallOptions = { isStatic: true, render: { visible: false } };
        Composite.add(world, [
            Bodies.rectangle(200, 595, 400, 10, wallOptions), // 바닥
            Bodies.rectangle(5, 300, 10, 600, wallOptions),  // 왼쪽 벽
            Bodies.rectangle(395, 300, 10, 600, wallOptions) // 오른쪽 벽
        ]);

        // 3. 과일 생성 함수
        function createFruit(x, y, level, isStatic = false) {
            const fruitData = FRUITS[level - 1];
            const indexStr = String(level - 1).padStart(2, '0'); 
            const prefix = (currentSkinType === 'A') ? 'fruit' : 'skinB_fruit';
            const texturePath = `asset/${prefix}${indexStr}.png`; 

            const fruit = Bodies.circle(x, y, fruitData.radius, {
                label: `fruit_${level}`,
                isStatic: isStatic,
                restitution: 0.3,
                render: {
                    sprite: {
                        texture: texturePath,
                        xScale: (fruitData.radius * 2) / 100, // 이미지 크기에 맞춰 조절이 필요할 수 있음
                        yScale: (fruitData.radius * 2) / 100
                    }
                }
            });
            fruit.isMerging = false;
            return fruit;
        }

        function spawnFruit() {
            if (isGameOver) return;
            const level = Math.floor(Math.random() * 3) + 1;
            currentFruit = createFruit(200, 80, level, true);
            Composite.add(world, currentFruit);
            canDrop = true;
        }

        // 4. 스킨 변경 기능
        window.toggleSkin = function() {
            currentSkinType = (currentSkinType === 'A') ? 'B' : 'A';
            const prefix = (currentSkinType === 'A') ? 'fruit' : 'skinB_fruit';
            
            const fruits = Composite.allBodies(world).filter(b => b.label && b.label.startsWith('fruit_'));
            fruits.forEach(fruit => {
                const level = fruit.label.split('_')[1];
                const indexStr = String(level - 1).padStart(2, '0');
                fruit.render.sprite.texture = `asset/${prefix}${indexStr}.png`;
            });
            
            if (currentFruit) {
                const level = currentFruit.label.split('_')[1];
                const indexStr = String(level - 1).padStart(2, '0');
                currentFruit.render.sprite.texture = `asset/${prefix}${indexStr}.png`;
            }
        };

        // 5. 마우스 제어
        container.addEventListener('mousemove', (e) => {
            if (currentFruit && canDrop) {
                const rect = container.getBoundingClientRect();
                let x = e.clientX - rect.left;
                const radius = FRUITS[parseInt(currentFruit.label.split('_')[1]) - 1].radius;
                x = Math.max(radius + 10, Math.min(390 - radius, x));
                Body.setPosition(currentFruit, { x: x, y: 80 });
            }
        });

        container.addEventListener('click', () => {
            if (currentFruit && canDrop) {
                canDrop = false;
                Body.setStatic(currentFruit, false);
                currentFruit = null;
                setTimeout(spawnFruit, 1000);
            }
        });

        // 6. 충돌 및 합성
        Events.on(engine, 'collisionStart', (event) => {
            event.pairs.forEach((pair) => {
                const { bodyA, bodyB } = pair;
                if (bodyA.label === bodyB.label && bodyA.label.startsWith('fruit_')) {
                    if (bodyA.isMerging || bodyB.isMerging) return;
                    const level = parseInt(bodyA.label.split('_')[1]);
                    if (level < 11) {
                        bodyA.isMerging = true;
                        bodyB.isMerging = true;
                        mergeQueue.push({
                            bodyA, bodyB, level,
                            x: (bodyA.position.x + bodyB.position.x) / 2,
                            y: (bodyA.position.y + bodyB.position.y) / 2
                        });
                    }
                }
            });
        });

        Events.on(engine, 'afterUpdate', () => {
            while (mergeQueue.length > 0) {
                const { bodyA, bodyB, level, x, y } = mergeQueue.shift();
                if (Composite.allBodies(world).includes(bodyA)) {
                    Composite.remove(world, [bodyA, bodyB]);
                    Composite.add(world, createFruit(x, y, level + 1));
                    score += FRUITS[level - 1].score;
                    document.getElementById('score').innerText = score;
                }
            }
        });

        // 7. 게임 시작
        Render.run(render);
        const runner = Runner.create({ isFixed: true });
        Runner.run(runner, engine);
        spawnFruit();

        window.resetGame = () => location.reload();
    </script>
</body>
</html>

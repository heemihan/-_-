<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>수박 게임 - 최종 수정본</title>
    <style>
        body {
            margin: 0; padding: 0;
            display: flex; justify-content: center; align-items: center;
            height: 100vh; background-color: #1a1a1a;
            overflow: hidden; font-family: 'Pretendard', sans-serif;
        }

        /* 게임 영역을 화면 중앙에 고정 */
        #game-outer {
            position: relative;
            width: 400px;
            height: 600px;
            border: 4px solid #333;
            border-radius: 12px;
            overflow: hidden;
            background-color: #ffeeb0; /* 배경 이미지 로드 전 기본색 */
        }

        /* UI 요소들을 위한 레이어 */
        .ui-element {
            position: absolute;
            z-index: 10;
            pointer-events: auto;
        }

        .score-board {
            top: 20px; left: 20px;
            color: #333; font-size: 24px; font-weight: 800;
            pointer-events: none;
        }

        .top-controls {
            top: 15px; right: 15px;
            display: flex; gap: 10px;
        }

        .control-btn {
            width: 40px; height: 40px;
            cursor: pointer;
        }

        /* Matter.js가 생성하는 캔버스를 부모 크기에 맞춤 */
        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
        }
    </style>
</head>
<body>

    <div id="game-outer">
        <div class="ui-element score-board">SCORE: <span id="score">0</span></div>
        
        <div class="ui-element top-controls">
            <img src="asset/imgchange.png" class="control-btn" onclick="toggleSkin()" alt="Skin">
            <img src="asset/resetGame.png" class="control-btn" onclick="resetGame()" alt="Reset">
        </div>
        
        <div id="game-container"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <script>
        const { Engine, Render, Runner, Bodies, Composite, Events, Body } = Matter;

        const engine = Engine.create();
        const world = engine.world;
        const container = document.getElementById('game-container');
        const outer = document.getElementById('game-outer');

        let currentSkinType = 'A'; 
        const mergeQueue = []; 
        let score = 0;
        let isGameOver = false;
        let currentFruit = null;
        let canDrop = true;

        const FRUITS = [
            { radius: 17.5, score: 2 }, { radius: 27.5, score: 4 }, { radius: 42.5, score: 8 },
            { radius: 52.5, score: 16 }, { radius: 67.5, score: 32 }, { radius: 82.5, score: 64 },
            { radius: 97.5, score: 128 }, { radius: 117.5, score: 256 }, { radius: 137.5, score: 512 },
            { radius: 157.5, score: 1024 }, { radius: 187.5, score: 2048 }
        ];

        // 1. 렌더러 설정 (배경 이미지 포함)
        const render = Render.create({
            element: container,
            engine: engine,
            options: {
                width: 400,
                height: 600,
                wireframes: false,
                background: 'asset/background.png' // 배경 이미지가 여기서 날아갔을 수 있으므로 직접 지정
            }
        });

        // 2. 벽 생성 (벽 두께를 늘려 안정성 확보)
        const wallOptions = { isStatic: true, render: { visible: false } };
        Composite.add(world, [
            Bodies.rectangle(200, 610, 400, 30, wallOptions), // 바닥
            Bodies.rectangle(-15, 300, 30, 600, wallOptions), // 왼쪽
            Bodies.rectangle(415, 300, 30, 600, wallOptions)  // 오른쪽
        ]);

        function createFruit(x, y, level, isStatic = false) {
            const fruitData = FRUITS[level - 1];
            const indexStr = String(level - 1).padStart(2, '0'); 
            const prefix = (currentSkinType === 'A') ? 'fruit' : 'skinB_fruit';
            
            const fruit = Bodies.circle(x, y, fruitData.radius, {
                label: `fruit_${level}`,
                isStatic: isStatic,
                restitution: 0.3,
                render: {
                    sprite: {
                        texture: `asset/${prefix}${indexStr}.png`,
                        xScale: 1, // 이미지 원래 크기가 반지름과 맞지 않으면 이 값을 조정해야 함
                        yScale: 1
                    }
                }
            });
            fruit.isMerging = false;
            return fruit;
        }

        function spawnFruit() {
            if (isGameOver) return;
            const level = Math.floor(Math.random() * 3) + 1;
            currentFruit = createFruit(200, 80, level, true);
            Composite.add(world, currentFruit);
            canDrop = true;
        }

        // 3. 마우스 이동 로직 (좌표 오차 수정)
        const handleMove = (e) => {
            if (currentFruit && canDrop && !isGameOver) {
                const rect = container.getBoundingClientRect();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                let x = clientX - rect.left;
                
                const level = parseInt(currentFruit.label.split('_')[1]);
                const radius = FRUITS[level - 1].radius;
                
                // 벽 안쪽으로 이동 제한
                x = Math.max(radius + 10, Math.min(390 - radius, x));
                Body.setPosition(currentFruit, { x: x, y: 80 });
            }
        };

        // 이벤트 리스너를 컨테이너에 직접 연결
        outer.addEventListener('mousemove', handleMove);
        outer.addEventListener('touchmove', handleMove);

        outer.addEventListener('click', () => {
            if (currentFruit && canDrop && !isGameOver) {
                canDrop = false;
                Body.setStatic(currentFruit, false);
                currentFruit = null;
                setTimeout(spawnFruit, 1000);
            }
        });

        // 4. 충돌 및 점수
        Events.on(engine, 'collisionStart', (event) => {
            event.pairs.forEach((pair) => {
                const { bodyA, bodyB } = pair;
                if (bodyA.label === bodyB.label && bodyA.label.startsWith('fruit_')) {
                    if (bodyA.isMerging || bodyB.isMerging) return;
                    const level = parseInt(bodyA.label.split('_')[1]);
                    if (level < 11) {
                        bodyA.isMerging = true;
                        bodyB.isMerging = true;
                        mergeQueue.push({ bodyA, bodyB, level, x: (bodyA.position.x + bodyB.position.x) / 2, y: (bodyA.position.y + bodyB.position.y) / 2 });
                    }
                }
            });
        });

        Events.on(engine, 'afterUpdate', () => {
            while (mergeQueue.length > 0) {
                const { bodyA, bodyB, level, x, y } = mergeQueue.shift();
                if (Composite.allBodies(world).includes(bodyA)) {
                    Composite.remove(world, [bodyA, bodyB]);
                    Composite.add(world, createFruit(x, y, level + 1));
                    score += FRUITS[level - 1].score;
                    document.getElementById('score').innerText = score;
                }
            }
        });

        window.toggleSkin = function() {
            currentSkinType = (currentSkinType === 'A') ? 'B' : 'A';
            const prefix = (currentSkinType === 'A') ? 'fruit' : 'skinB_fruit';
            Composite.allBodies(world).forEach(body => {
                if (body.label && body.label.startsWith('fruit_')) {
                    const level = body.label.split('_')[1];
                    body.render.sprite.texture = `asset/${prefix}${String(level-1).padStart(2,'0')}.png`;
                }
            });
        };

        window.resetGame = () => location.reload();

        Render.run(render);
        Runner.run(Runner.create({ isFixed: true }), engine);
        spawnFruit();
    </script>
</body>
</html>
